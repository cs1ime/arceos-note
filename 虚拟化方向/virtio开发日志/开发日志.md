virtio文档：

https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter9/2device-driver-2.html#

virtio设备例子（这个是基于KVM的API）

https://github.com/openanolis/dragonball-sandbox/tree/main/crates/dbs-virtio-devices

virtio驱动仓库（rcore的驱动）

https://github.com/rcore-os/virtio-drivers  切换到这个commit `git checkout 4ee80e5`





为了能使得Guest读写mmio的操作能方便让hypervisor识别，我写了一个汇编文件专门处理Guest写入mmio寄存器

```
.section .text

__mmio_readbyte:
    mov al,[rdi]
    ret;

__mmio_writebyte:
    mov [rdi],sil
    ret;

__mmio_readword:
    mov eax,[rdi]
    ret;

__mmio_writeword:
    mov [rdi],esi
    ret;

```



**有一个大坑： vmx不能在eptviolation的时候解析触发异常的指令的操作数，这导致需要用反汇编引擎来解析对mmio地址区域访问的指令。QEMU/KVM用的是模拟指令来处理mmio地址访问，这种方法太过麻烦，我直接硬编码al,eax为读取mmio返回寄存器，sil,esi做为写入mmio的数据寄存器**

应对这个问题我还有一个解决方案，借鉴Epthook的思路，先不分配mmio内存区域的Ept页表项，Guest读写触发Ept violation 的内存读写指令的时候申请一个mmio寄存器页面，把设备对象管理的mmio寄存器的值填充进去，把mmio寄存器页面的物理地址填充进这个页表项里去并执行`invept`，设置VMCS中的MTF标志位使得Guest内存读写指令执行结束后触发MTF vmexit，Host捕获到MTF vmexit之后把mmio寄存器页面的修改映射到设备对象里去



## nimbos驱动实现

把virtio-drivers的blk源码搬过来作为nimbos的驱动,用我写的 `mmio_*` 一系列内存访问函数实现一次Volatile库的接口然后代替之



virtio的寄存器描述：

https://github.com/rcore-os/virtio-drivers/blob/4ee80e50babd681869f428ee026167bc12dc6856/src/header.rs





